# 1-2. OS (Linux) の基礎知識

この節では、OSのカーネルとプロセスについて説明します。

## OSとカーネル

皆さんご存知の通り、OSは**コンピューター全体の動作を管理・制御**し、コンピューター上で我々が書いたプログラムが動くようにしてくれるソフトウェアです。  
全てのOSは、様々な部品で成り立っています。その中で最も重要な役割を担うのが**カーネル**です。

![OSとカーネル](./1.dio.png)

カーネルは、**CPU・メモリの直接制御**を担う、OSの中核部品です。  
一般的なOSは、このカーネルの上にシェル・デーモン・コマンドなど、**カーネルをより使いやすく**する部品を一緒に提供しています。

実は、**Linux**というのはこの**カーネル部分だけ**を指します。Linux公式はカーネルしか提供していません。  
Linuxカーネルに様々な部品を上乗せしてセットで提供しているのが、**Ubuntu**や**RHEL**に代表される**Linuxディストリビューション** (Distro) です。  
このディストリビューションこそ、私たちが普段**OSと呼んでいるもの**です。

皆さんが普段使うシェルやコマンドは基本この**ディストリビューションが提供**しているものであり、Linuxカーネルを直接触ることはほとんど**ありません**。  
(厳密に言えば、ディストリビューションが上乗せする部品のほとんどは他団体が管理するOSSで、ディストリビューションの仕事はそれらを選定し便利に提供することです。詳細は省きます)

Linux本体とディストリビューションの違いがわかっていなかった方は、ぜひこの機会に覚えておいて下さいね！

## プロセス

ここからはLinuxに対象を絞って話を進めます。

アプリケーションを実行すると、OSの中では**プロセス**という実態が生成されます。  
アプリケーションが設計図、プロセスがそれを元に作られた実際の製品というイメージですね。

プロセスは1つ1つがID (**プロセスID**/**PID**) を持ち、これをもって識別されます。PIDは**インクリメンタル**で、一回の起動期間の間は**全てのプロセスでユニーク**です。  
また、プロセスはいきなり何もないところから発生するわけではなく、自分を**コピーしてプロセスを生成**すること (**fork**) で増えていきます。  
forkされたプロセスは原則フォーク元プロセスの**子プロセス**となり、**プロセスグループ**として紐づけがされます。

![プロセスとフォーク](./2.dio.png)

プロセスを増やす方法はフォークしかありません。プロセスを増やすときは、全て**前のプロセスのコピー**なのです。

「ではシェルで**別のプログラムを起動する**ときはどうしてるんだ」と皆さん疑問に思ったことでしょう。  
そのために**exec**という処理が存在します。これは、**プロセス本体/PIDを変えない**まま、プロセスで実行するプログラムを**まるっと入れ替える**処理です。  
別プログラムを子プロセスで実行したいとき、実は裏で**forkしてから子プロセスでexecする**という処理が行われています。

つまり、先程の「アプリケーションを実行するとプロセスになる」という説明は実は**正確ではなく**、**プロセスは器**であり、**器を増やしてアプリケーションを入れる**ことで作られる、という説明の方が正確です。

![forkとexec](./3.dio.png)

また、プロセスからプロセスが生まれるのであれば、**最初のプロセスはどこで生まれる**のでしょう？  
実は、Linuxが必ず**最初に直接起動**するプロセスが存在し、これは**initプロセス**と呼ばれます。これのPIDは**必ず1**になります。  
initプロセスは**他の全てのプロセスの親**であり、他のプロセスは**initプロセスをルートとする木構造**を成します。

![initプロセスからの木](./4.dio.png)

このプロセスの木構造は、`pstree`コマンドを使うことで確認することができます。

```console
$ pstree
systemd-+-ModemManager---3*[{ModemManager}]
        |-agetty
        |-containerd---14*[{containerd}]
        |-containerd-shim-+-php-fpm---2*[php-fpm]
        |                 `-10*[{containerd-shim}]
        |-containerd-shim-+-mysqld---34*[{mysqld}]
        |                 `-10*[{containerd-shim}]
        |-cron
        |-dbus-daemon
        |-dockerd-+-5*[docker-proxy---7*[{docker-proxy}]]
        |         |-2*[docker-proxy---6*[{docker-proxy}]]
        |         `-27*[{dockerd}]
        |-fwupd---5*[{fwupd}]
        |-mdadm
        |-multipathd---6*[{multipathd}]
        |-polkitd---3*[{polkitd}]
        |-rsyslogd---3*[{rsyslogd}]
        |-sshd
        |-systemd-journal
        |-systemd-logind
        |-systemd-network
        |-systemd-resolve
        |-systemd-timesyn---{systemd-timesyn}
        |-systemd-udevd
        |-tailscaled---13*[{tailscaled}]
        |-thermald---4*[{thermald}]
        |-udisksd---5*[{udisksd}]
        |-unattended-upgr---{unattended-upgr}
        `-upowerd---3*[{upowerd}]
```

これらの木構造の**枝部分**は、カーネル内で**プロセスグループ**や**セッション**といったまとまりで管理されます。

## スレッド

プロセスの亜種として**スレッド**というものも存在します。  
プロセスの場合はフォークする時**メモリの中身** (≒ 変数内のデータ) **がコピー**されますが、スレッドの場合は紐づいた**全てのスレッド同士で多くのデータが共有**されます。レジスタなど一部のデータは共有されません。  
プロセスよりもスレッドの方が**生成・切り替えが軽量**で、**goroutineの裏側ではスレッド**が使われていたりします。
